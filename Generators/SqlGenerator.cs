using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text.RegularExpressions;

namespace Generators;

/// <summary>
///     Finds all files ending with .sql in the project.
///     Generates a public static partial class named SqlFiles with const static string fields.
///     Each field has the normalized name of a single .sql file and contains its contents.
/// </summary>
/// <example>var content = SqlFiles.NameOfSqlFile</example>
[Generator(LanguageNames.CSharp)]
public class SqlGenerator : ISourceGenerator
{
    private SyntaxTree _tree;
    private string _projectRootPath = string.Empty;
    
    public SqlGenerator()
    {
        // build an empty SqlFiles class syntax tree
        _tree = SyntaxFactory.SyntaxTree(
            SyntaxFactory.CompilationUnit()
                .WithMembers(
                    SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                        SyntaxFactory.FileScopedNamespaceDeclaration(
                                SyntaxFactory.QualifiedName(
                                    SyntaxFactory.IdentifierName("Experiments"),
                                    SyntaxFactory.IdentifierName("CanIHazSourceGeneratedSql")))
                            .WithNamespaceKeyword(
                                SyntaxFactory.Token(
                                    SyntaxFactory.TriviaList(
                                        SyntaxFactory.Comment("// <auto-generated/>")),
                                    SyntaxKind.NamespaceKeyword,
                                    SyntaxFactory.TriviaList()))
                            .WithMembers(
                                SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                                    SyntaxFactory.ClassDeclaration("SqlFiles")
                                        .WithModifiers(
                                            SyntaxFactory.TokenList(
                                                SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                                                SyntaxFactory.Token(SyntaxKind.StaticKeyword),
                                                SyntaxFactory.Token(SyntaxKind.PartialKeyword)))))))
                .NormalizeWhitespace());
    }

    public void Execute(GeneratorExecutionContext execContext)
    {
        execContext.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDir);
        _projectRootPath = Path.GetDirectoryName(projectDir);
        
        // find all additional files that end with .sql
        var sqlFiles = execContext.AdditionalFiles
            .Where(static file => file.Path.EndsWith(".sql"))
            .Select((additionalText) => new TextDetail
            {
                Path = additionalText.Path,
                Content = SymbolDisplay.FormatLiteral(additionalText.GetText()!.ToString(), false)
            });
        
        foreach (var item in sqlFiles)
            AddSqlMember(item.Path, item.Content);
        
        execContext.AddSource("SqlFiles.generated.cs", Regex.Unescape(_tree.ToString())); 
    }
    
    public void Initialize(GeneratorInitializationContext initContext) { }

    private void AddSqlMember(string sqlFilePath, string content)
    {
        if (TryGetClassDeclaration("SqlFiles", out var parent))
        {
            var pathComponents = GetLocalPathComponents(sqlFilePath);

            foreach (var component in pathComponents)
            {
                if (TryGetClassDeclaration(component, out var nested))
                    parent = nested;
                else
                    parent = AddClassDeclaration(parent!, component);
            }

            var memberName = Path.GetFileNameWithoutExtension(sqlFilePath);
            
            if (HasSqlMemberAsChildNode(parent!, memberName))
                parent = RemoveSqlMemberChildNode(parent!, memberName, content);
            
            AddSqlMemberAsChildNode(parent!, memberName, content);
        }
    }

    private ClassDeclarationSyntax RemoveSqlMemberChildNode(ClassDeclarationSyntax parentNode, string memberName, string content)
    {
        var existing = parentNode.DescendantNodes(_ => true)
            .OfType<VariableDeclaratorSyntax>()
            .First(decl => decl.Identifier.ToString().Equals(memberName, StringComparison.InvariantCultureIgnoreCase));
        
        return parentNode.RemoveNode(existing, SyntaxRemoveOptions.KeepNoTrivia)!;
    }

    private bool HasSqlMemberAsChildNode(ClassDeclarationSyntax parent, string memberName)
    {
        return parent.DescendantNodes(_ => true)
            .OfType<VariableDeclaratorSyntax>()
            .Any(decl => decl.Identifier.ToString().Equals(memberName, StringComparison.InvariantCultureIgnoreCase));
    }

    private bool TryGetClassDeclaration(string identifier, out ClassDeclarationSyntax? node)
    {
        node = _tree.GetRoot()
            .DescendantNodes(_ => true)
            .OfType<ClassDeclarationSyntax>()
            .FirstOrDefault(decl => decl.Identifier.ToString().Equals(
                identifier, StringComparison.InvariantCultureIgnoreCase));

        return node != null;
    }

    private ImmutableArray<string> GetLocalPathComponents(string sqlFilePath)
    {
        var fileName = Path.GetFileName(sqlFilePath);
        var result = ImmutableArray<string>.Empty;

        if (Path.Combine(_projectRootPath, fileName).Length < sqlFilePath.Length)
        {
            var path = sqlFilePath.Substring(
                _projectRootPath.Length,
                sqlFilePath.Length - fileName.Length - _projectRootPath.Length);

            result = path
                .Split(Path.DirectorySeparatorChar)
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .ToImmutableArray();
        }

        return result;
    }

    private ClassDeclarationSyntax? AddClassDeclaration(ClassDeclarationSyntax parentNode, string childIdentifier)
    {
        var newClassDeclaration = parentNode.AddMembers(
            SyntaxFactory.ClassDeclaration(childIdentifier)
                    .WithModifiers(
                        SyntaxFactory.TokenList(
                            SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                            SyntaxFactory.Token(SyntaxKind.StaticKeyword))));

        MutateTree(parentNode, newClassDeclaration);

        TryGetClassDeclaration(childIdentifier, out var result);
        return result;
    }

    private void AddSqlMemberAsChildNode(ClassDeclarationSyntax parentNode, string memberName, string content)
    {
        // add a const string member for the sql file name and content
        var newClassDeclaration = parentNode.AddMembers(
            SyntaxFactory.FieldDeclaration(
                    SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.PredefinedType(
                                SyntaxFactory.Token(SyntaxKind.StringKeyword)))
                        .WithVariables(
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.VariableDeclarator(
                                        SyntaxFactory.Identifier(memberName))
                                    .WithInitializer(
                                        SyntaxFactory.EqualsValueClause(
                                            SyntaxFactory.LiteralExpression(
                                                SyntaxKind.StringLiteralExpression,
                                                SyntaxFactory.Literal(content)))))))
                .WithModifiers(
                    SyntaxFactory.TokenList(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.ConstKeyword))));

        MutateTree(parentNode, newClassDeclaration);
    }

    private void MutateTree(ClassDeclarationSyntax oldClassDeclaration, ClassDeclarationSyntax newClassDeclaration)
    {
        _tree = SyntaxFactory.SyntaxTree(
            _tree.GetRoot().ReplaceNode(oldClassDeclaration, newClassDeclaration)
                .NormalizeWhitespace());
    }

    private class TextDetail
    {
        public string Path { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
    }
}
